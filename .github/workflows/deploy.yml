name: Deploy Lambda Service

on:
  push:
    branches: [ main, 'feat/ekene/interview/exercise' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      aws_region:
        description: 'AWS Region'
        required: false
        default: 'us-east-1'
        type: string
      project_name:
        description: 'Project Name'
        required: false
        default: 'guild'
        type: string
      service_name:
        description: 'Service Name'
        required: false
        default: 'hello-service'
        type: string
      aws_access_key_id:
        description: 'AWS Access Key ID (optional - will use secrets if not provided)'
        required: false
        type: string
      aws_secret_access_key:
        description: 'AWS Secret Access Key (optional - will use secrets if not provided)'
        required: false
        type: string
      use_aws_role:
        description: 'Use AWS IAM Role instead of access keys'
        required: false
        default: false
        type: boolean
      aws_role_arn:
        description: 'AWS IAM Role ARN (if using role-based authentication)'
        required: false
        type: string


jobs:
  test:
    name: Test and Validate
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ github.event.inputs.python_version || '3.11' }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r src/requirements.txt
        
    - name: Run linting
      run: |
        flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
    - name: Run type checking
      run: |
        mypy src/ --ignore-missing-imports
        
        
    - name: Run tests
      run: |
        cd src
        python -m pytest test_validation.py -v --cov=hello_app --cov-report=xml
        
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./src/coverage.xml
        flags: unittests
        name: codecov-umbrella

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ github.event.inputs.python_version || '3.11' }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r src/requirements.txt
        pip install safety bandit
        
    - name: Run safety check
      run: |
        safety check --json --output safety-report.json || true
        
    - name: Run bandit security scan
      run: |
        bandit -r src/ -f json -o bandit-report.json || true
        
    - name: Upload security reports
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: |
          safety-report.json
          bandit-report.json

  build:
    name: Build Lambda Package
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ github.event.inputs.python_version || '3.11' }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r src/requirements.txt
        
    - name: Create deployment package
      run: |
        mkdir -p dist
        cd src
        zip -r ../dist/lambda.zip . -x "*.pyc" "__pycache__/*" "test_*.py" "*.md"
        
        
    - name: Upload Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: lambda-package
        path: dist/lambda.zip

  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'dev' }}
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/feat/ekene/interview/exercise' || github.event_name == 'workflow_dispatch'
    
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download Lambda package
      uses: actions/download-artifact@v4
      with:
        name: lambda-package
        path: dist/
      continue-on-error: false
        
    - name: Debug artifact download
      run: |
        echo "Current working directory: $(pwd)"
        echo "Contents of current directory:"
        ls -la
        echo "Contents of dist/ directory:"
        ls -la dist/ || echo "dist/ directory does not exist"
        echo "Looking for lambda.zip:"
        find . -name "lambda.zip" -type f 2>/dev/null || echo "lambda.zip not found"
        echo "Checking if artifact download worked..."
        if [ -f "dist/lambda.zip" ]; then
          echo "✅ Artifact download successful!"
          ls -la dist/lambda.zip
        else
          echo "❌ Artifact download failed!"
          echo "Available artifacts:"
          ls -la dist/ || echo "No dist/ directory"
        fi
        
    - name: Verify Lambda package
      run: |
        echo "Checking if Lambda package exists..."
        ls -la dist/
        if [ -f "dist/lambda.zip" ]; then
          echo "✅ Lambda package found: dist/lambda.zip"
          ls -la dist/lambda.zip
        else
          echo "❌ Lambda package not found!"
          echo "Contents of dist/:"
          ls -la dist/ || echo "dist/ directory does not exist"
          exit 1
        fi
        
    - name: Display deployment inputs
      run: |
        echo " Deployment Configuration:"
        echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
        echo "AWS Region: ${{ github.event.inputs.aws_region || 'us-west-2' }}"
        echo "Project Name: ${{ github.event.inputs.project_name || 'guild' }}"
        echo "Service Name: ${{ github.event.inputs.service_name || 'hello-service' }}"
        echo "AWS Access Key ID: ${{ github.event.inputs.aws_access_key_id != '' && '***PROVIDED***' || 'NOT PROVIDED' }}"
        echo "AWS Secret Access Key: ${{ github.event.inputs.aws_secret_access_key != '' && '***PROVIDED***' || 'NOT PROVIDED' }}"
        echo "Use AWS Role: ${{ github.event.inputs.use_aws_role || 'false' }}"
        echo "AWS Role ARN: ${{ github.event.inputs.aws_role_arn || 'NOT PROVIDED' }}"
        
    - name: Check AWS credentials
      run: |
        echo "Checking AWS credentials..."
        
        # For manual triggers, check inputs first
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          if [ -n "${{ github.event.inputs.aws_access_key_id }}" ] && [ -n "${{ github.event.inputs.aws_secret_access_key }}" ]; then
            echo "Using credentials from workflow inputs (manual trigger)"
          elif [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "Using credentials from GitHub Secrets (manual trigger)"
          else
            echo "No AWS credentials found for manual trigger!"
            echo "Please provide AWS credentials in the workflow inputs or set GitHub Secrets"
            exit 1
          fi
        else
          # For automatic triggers, use secrets
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "Using credentials from GitHub Secrets (automatic trigger)"
          else
            echo "No AWS credentials found in GitHub Secrets!"
            echo "Please set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY in repository secrets"
            exit 1
          fi
        fi
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ github.event.inputs.aws_access_key_id || secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ github.event.inputs.aws_secret_access_key || secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ github.event.inputs.aws_region || 'us-east-1' }}
        role-to-assume: ${{ github.event.inputs.use_aws_role == 'true' && github.event.inputs.aws_role_arn || '' }}
        
    - name: Verify AWS credentials
      run: |
        echo "Verifying AWS credentials..."
        aws sts get-caller-identity
        echo "AWS credentials verified successfully"
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        
    - name: Create Environment Configuration
      run: |
        # Create environment directory if it doesn't exist
        mkdir -p iac/environments/${{ github.event.inputs.environment || 'dev' }}
        
        # Create main.tf for the environment
        cat > iac/environments/${{ github.event.inputs.environment || 'dev' }}/main.tf << EOF
        terraform {
          required_providers {
            aws = {
              source  = "hashicorp/aws"
              version = "~> 5.0"
            }
          }
        }
        
        provider "aws" {
          region = "${{ github.event.inputs.aws_region || 'us-east-1' }}"
          
          default_tags {
            tags = {
              Project     = "${{ github.event.inputs.project_name || 'guild' }}"
              Environment = "${{ github.event.inputs.environment || 'dev' }}"
              Service     = "${{ github.event.inputs.service_name || 'hello-service' }}"
              ManagedBy   = "terraform"
              Owner       = "devops-team"
            }
          }
        }
        
        data "aws_caller_identity" "current" {}
        data "aws_region" "current" {}
        
        locals {
          common_tags = {
            Project     = "${{ github.event.inputs.project_name || 'guild' }}"
            Environment = "${{ github.event.inputs.environment || 'dev' }}"
            Service     = "${{ github.event.inputs.service_name || 'hello-service' }}"
            ManagedBy   = "terraform"
            Owner       = "devops-team"
          }
        }
        
        module "lambda_service" {
          source = "../../modules/lambda-service"
          
          project_name = "${{ github.event.inputs.project_name || 'guild' }}"
          environment  = "${{ github.event.inputs.environment || 'dev' }}"
          service_name = "${{ github.event.inputs.service_name || 'hello-service' }}"
          tags         = local.common_tags
          
          lambda_package_path = "../../dist/lambda.zip"
          lambda_handler      = "hello_app.lambda_handler"
          lambda_runtime      = "python3.11"
          lambda_timeout      = 30
          lambda_memory_size  = 256
          
          environment_variables = {
            ENVIRONMENT      = "${{ github.event.inputs.environment || 'dev' }}"
            SERVICE_VERSION  = "1.0.0"
            LOG_LEVEL        = "INFO"
            GREETING_MESSAGE = "Hello from ${{ github.event.inputs.environment || 'dev' }}!"
          }
          
          log_retention_days = 14
          enable_api_gateway = true
          api_path          = "hello"
          api_method        = "POST"
          api_authorization  = "NONE"
          enable_encryption = true
          tracing_mode      = "PassThrough"
          
          ssm_parameters = {
            greeting_message = {
              name        = "/${{ github.event.inputs.project_name || 'guild' }}/${{ github.event.inputs.service_name || 'hello-service' }}/message"
              type        = "String"
              value       = "Hello from ${{ github.event.inputs.environment || 'dev' }}!"
              description = "Greeting message for ${{ github.event.inputs.environment || 'dev' }} environment"
              tags        = local.common_tags
            }
          }
          
          error_threshold = 5
          alarm_actions   = []
          ok_actions      = []
          enable_dashboard = true
          custom_metrics = {}
          
          enable_provisioned_concurrency = false
          provisioned_concurrency_count  = 1
          enable_auto_scaling           = false
          min_provisioned_concurrency   = 1
          max_provisioned_concurrency   = 10
          target_utilization           = 0.7
          scale_out_cooldown           = 300
          scale_in_cooldown            = 300
        }
        EOF
        
        # Create outputs.tf for the environment
        cat > iac/environments/${{ github.event.inputs.environment || 'dev' }}/outputs.tf << EOF
        output "lambda_function_name" {
          description = "Name of the Lambda function"
          value       = module.lambda_service.lambda_function_name
        }
        
        output "api_gateway_url" {
          description = "URL of the API Gateway"
          value       = module.lambda_service.api_gateway_url
        }
        
        output "dashboard_url" {
          description = "URL of the CloudWatch dashboard"
          value       = module.lambda_service.dashboard_url
        }
        
        output "service_info" {
          description = "Service information"
          value       = module.lambda_service.service_info
        }
        EOF
        
    - name: Setup Terraform Backend (if needed)
      run: |
        # Use provided bucket name or create a persistent one
        BUCKET_NAME="${{ secrets.TERRAFORM_STATE_BUCKET || 'guild-terraform-state-persistent' }}"
        TABLE_NAME="${{ secrets.TERRAFORM_STATE_DYNAMODB_TABLE || 'terraform-state-lock' }}"
        REGION="${{ github.event.inputs.aws_region || 'us-east-1' }}"
        
        echo "Setting up Terraform backend infrastructure..."
        echo "Using bucket: $BUCKET_NAME"
        
        # Create S3 bucket if it doesn't exist
        if ! aws s3 ls s3://$BUCKET_NAME 2>/dev/null; then
          echo "Creating S3 bucket: $BUCKET_NAME"
          
          # Try to create bucket, if it fails due to name conflict, try with suffix
          if ! aws s3 mb s3://$BUCKET_NAME --region $REGION 2>/dev/null; then
            echo "Bucket name conflict, trying with suffix..."
            SUFFIX=$(date +%s | tail -c 6)
            BUCKET_NAME="${BUCKET_NAME}-${SUFFIX}"
            echo "Using bucket: $BUCKET_NAME"
            aws s3 mb s3://$BUCKET_NAME --region $REGION
          fi
          
          # Store the final bucket name for later steps
          echo "TERRAFORM_BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV
          
          echo "Enabling versioning..."
          aws s3api put-bucket-versioning \
            --bucket $BUCKET_NAME \
            --versioning-configuration Status=Enabled
          
          echo "Enabling encryption..."
          aws s3api put-bucket-encryption \
            --bucket $BUCKET_NAME \
            --server-side-encryption-configuration '{
              "Rules": [
                {
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }
              ]
            }'
          
          echo "Blocking public access..."
          aws s3api put-public-access-block \
            --bucket $BUCKET_NAME \
            --public-access-block-configuration \
            BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
        else
          echo "S3 bucket $BUCKET_NAME already exists"
        fi
        
        # Always set the bucket name for later steps
        echo "TERRAFORM_BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV
        
        # Create DynamoDB table if it doesn't exist
        if ! aws dynamodb describe-table --table-name $TABLE_NAME --region $REGION 2>/dev/null; then
          echo "Creating DynamoDB table: $TABLE_NAME"
          aws dynamodb create-table \
            --table-name $TABLE_NAME \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
            --region $REGION
          
          echo "Waiting for table to be active..."
          aws dynamodb wait table-exists --table-name $TABLE_NAME --region $REGION
        else
          echo "DynamoDB table $TABLE_NAME already exists"
        fi
        
        echo "Backend infrastructure ready!"
        
    - name: Verify Lambda package before Terraform
      run: |
        echo "Verifying Lambda package exists before Terraform..."
        echo "Current directory: $(pwd)"
        echo "Contents of dist/:"
        ls -la dist/ || echo "dist/ directory does not exist"
        echo "Looking for lambda.zip:"
        find . -name "lambda.zip" -type f 2>/dev/null || echo "lambda.zip not found"
        echo "Checking from iac/environments/dev/ perspective:"
        ls -la ../../dist/ || echo "../../dist/ does not exist"
        if [ -f "dist/lambda.zip" ]; then
          echo "✅ Lambda package verified: dist/lambda.zip"
          ls -la dist/lambda.zip
        else
          echo "❌ Lambda package not found!"
          exit 1
        fi
        
    - name: Terraform Init
      run: |
        cd iac/environments/${{ github.event.inputs.environment || 'dev' }}
        
        # Use the bucket name from the setup step or fallback to secret/default
        BUCKET_NAME="${{ env.TERRAFORM_BUCKET_NAME || secrets.TERRAFORM_STATE_BUCKET || 'guild-terraform-state-persistent' }}"
        echo "Using bucket: $BUCKET_NAME"
        
        terraform init \
          -backend-config="bucket=$BUCKET_NAME" \
          -backend-config="key=lambda-service/${{ github.event.inputs.environment || 'dev' }}/terraform.tfstate" \
          -backend-config="region=${{ github.event.inputs.aws_region || 'us-east-1' }}" \
          -backend-config="dynamodb_table=${{ secrets.TERRAFORM_STATE_DYNAMODB_TABLE || 'terraform-state-lock' }}" \
          -backend-config="encrypt=true"
        
    - name: Terraform Plan
      run: |
        cd iac/environments/${{ github.event.inputs.environment || 'dev' }}
        terraform plan -out=tfplan
        
    - name: Terraform Apply
      run: |
        cd iac/environments/${{ github.event.inputs.environment || 'dev' }}
        terraform apply -auto-approve tfplan
        
    - name: Run integration tests
      run: |
        # Get the API Gateway URL from Terraform output
        API_URL=$(cd iac/environments/${{ github.event.inputs.environment || 'dev' }} && terraform output -raw api_gateway_url)
        if [ "$API_URL" != "null" ]; then
          echo "Testing API endpoint: $API_URL"
          curl -X POST "$API_URL" \
            -H "Content-Type: application/json" \
            -d '{"name": "GitHub Actions"}' \
            --fail --show-error
        fi

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: Notify Success
      if: ${{ needs.deploy.result == 'success' }}
      run: |
        echo "Deployment completed successfully!"
        
    - name: Notify Failure
      if: ${{ needs.deploy.result == 'failure' }}
      run: |
        echo "Deployment failed!"
        exit 1
